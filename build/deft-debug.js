/*
DeftJS 0.6

Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
@private

Used by {@link Deft.ioc.Injector}.
*/
Ext.define('Deft.ioc.DependencyProvider', {
  config: {
    identifier: null,
    /**
    		Class to be instantiated, by either full name, alias or alternate name, to resolve this dependency.
    */
    className: null,
    /**
    		Optional arguments to pass to the class' constructor when instantiating a class to resolve this dependency.
    */
    parameters: null,
    /**
    		Factory function to be executed to obtain the corresponding object instance or value to resolve this dependency.
    		
    		NOTE: For lazily instantiated dependencies, this function will be passed the object instance for which the dependency is being resolved.
    */
    fn: null,
    /**
    		Value to use to resolve this dependency.
    */
    value: null,
    /**
    		Indicates whether this dependency should be resolved as a singleton, or as a transient value for each resolution request.
    */
    singleton: true,
    /**
    		Indicates whether this dependency should be 'eagerly' instantiated when this provider is defined, rather than 'lazily' instantiated when later requested.
    		
    		NOTE: Only valid when either a factory function or class is specified as a singleton.
    */
    eager: false
  },
  constructor: function(config) {
    this.initConfig(config);
    if ((config.value != null) && config.value.constructor === Object) {
      this.setValue(config.value);
    }
    if (this.getEager()) {
      if (this.getValue() != null) {
        Ext.Error.raise("Error while configuring '" + (this.getIdentifier()) + "': a 'value' cannot be created eagerly.");
      }
      if (!this.getSingleton()) {
        Ext.Error.raise("Error while configuring '" + (this.getIdentifier()) + "': only singletons can be created eagerly.");
      }
    }
    if (!this.getSingleton()) {
      if (this.getValue() != null) {
        Ext.Error.raise("Error while configuring '" + (this.getIdentifier()) + "': a 'value' can only be configured as a singleton.");
      }
    }
    return this;
  },
  /**
  	Resolve a target instance's dependency with an object instance or value generated by this dependency provider.
  */
  resolve: function(targetInstance) {
    var instance, parameters;
    Ext.log("Resolving '" + (this.getIdentifier()) + "'.");
    if (this.getValue() != null) return this.getValue();
    instance = null;
    if (this.getFn() != null) {
      Ext.log("Executing factory function.");
      instance = this.fn(targetInstance);
    } else if (this.getClassName() != null) {
      Ext.log("Creating instance of '" + (this.getClassName()) + "'.");
      parameters = this.getParameters() != null ? [this.getClassName()].concat(this.getParameters()) : [this.getClassName()];
      instance = Ext.create.apply(this, parameters);
    } else {
      Ext.Error.raise("Error while configuring rule for '" + (this.getIdentifier()) + "': no 'value', 'fn', or 'className' was specified.");
    }
    if (this.getSingleton()) this.setValue(instance);
    return instance;
  }
});

/**
A lightweight IoC container for dependency injection.

Used in conjunction with {@link Deft.mixin.Injectable}.
*/
Ext.define('Deft.ioc.Injector', {
  alternateClassName: ['Deft.Injector'],
  requires: ['Deft.ioc.DependencyProvider'],
  singleton: true,
  constructor: function() {
    this.providers = {};
    return this;
  },
  /**
  	Configure the Injector.
  */
  configure: function(configuration) {
    Ext.log('Configuring injector.');
    Ext.Object.each(configuration, function(identifier, config) {
      var provider;
      Ext.log("Configuring dependency provider for '" + identifier + "'.");
      if (Ext.isString(config)) {
        provider = Ext.create('Deft.ioc.DependencyProvider', {
          identifier: identifier,
          className: config
        });
      } else {
        provider = Ext.create('Deft.ioc.DependencyProvider', Ext.apply({
          identifier: identifier
        }, config));
      }
      this.providers[identifier] = provider;
    }, this);
    Ext.Object.each(this.providers, function(identifier, provider) {
      if (provider.getEager()) {
        Ext.log("Eagerly creating '" + (provider.getIdentifier()) + "'.");
        provider.resolve();
      }
    }, this);
  },
  /**
  	Indicates whether the Injector can resolve a dependency by the specified identifier with the corresponding object instance or value.
  */
  canResolve: function(identifier) {
    var provider;
    provider = this.providers[identifier];
    return provider != null;
  },
  /**
  	Resolve a dependency (by identifier) with the corresponding object instance or value.
  	
  	Optionally, the caller may specify the target instance (to be supplied to the dependency provider's factory function, if applicable).
  */
  resolve: function(identifier, targetInstance) {
    var provider;
    provider = this.providers[identifier];
    if (provider != null) {
      return provider.resolve(targetInstance);
    } else {
      return Ext.Error.raise("Error while resolving value to inject: no dependency provider found for '" + identifier + "'.");
    }
  },
  /**
  	Inject dependencies (by their identifiers) into the target object instance.
  */
  inject: function(identifiers, targetInstance) {
    var config, name, setterFunctionName, value;
    config = {};
    if (Ext.isString(identifiers)) identifiers = [identifiers];
    Ext.Object.each(identifiers, function(key, value) {
      var identifier, resolvedValue, targetProperty;
      targetProperty = Ext.isArray(identifiers) ? value : key;
      identifier = value;
      resolvedValue = this.resolve(identifier, targetInstance);
      if (targetInstance.config.hasOwnProperty(targetProperty)) {
        Ext.log("Injecting '" + identifier + "' into 'config." + targetProperty + "'.");
        config[targetProperty] = resolvedValue;
      } else {
        Ext.log("Injecting '" + identifier + "' into '" + targetProperty + "'.");
        targetInstance[targetProperty] = resolvedValue;
      }
    }, this);
    if (targetInstance.$configInited) {
      for (name in config) {
        value = config[name];
        setterFunctionName = 'set' + Ext.String.capitalize(name);
        targetInstance[setterFunctionName].call(targetInstance, value);
      }
    } else {
      targetInstance.config = Ext.Object.merge({}, targetInstance.config || {}, config);
    }
    return targetInstance;
  }
});

/**
A mixin that marks a class as participating in dependency injection.

Used in conjunction with {@link Deft.ioc.Injector}.
*/
Ext.define('Deft.mixin.Injectable', {
  requires: ['Deft.ioc.Injector'],
  /**
  	@private
  */
  onClassMixedIn: function(targetClass) {
    targetClass.prototype.constructor = Ext.Function.createInterceptor(targetClass.prototype.constructor, function() {
      return Deft.Injector.inject(this.inject, this);
    });
  }
});

/**
 A mixin that attaches a view to a view controller.

 Used in conjunction with {@link Deft.mvc.ViewController}.
 */
Ext.define('Deft.mixin.Controllable', {
    requires: ['Deft.mvc.ViewController'],
    /**
     @private
     */
    onClassMixedIn: function(targetClass) {
        targetClass.prototype.constructor = Ext.Function.createInterceptor(targetClass.prototype.constructor, function() {
            var controllers = Ext.isArray(this.controller) ? this.controller : [ this.controller ];
            Ext.each(controllers, function(controllerClass) {
                Ext.create(controllerClass, this);
            }, this);
        });
    }
});

/**
 A lightweight MVC view controller.

 Used in conjunction with {@link Deft.mixin.Controllable}.
 */
Ext.define('Deft.mvc.ViewController', {
    alternateClassName: ['Deft.ViewController'],
    constructor: function(view) {
        this.components = {view: view};
        view.on('initialize', this.configure, this);
        return this;
    },
    /**
     Configure the ViewController.
     */
    configure: function() {
        Ext.Logger.log('Configuring view controller.');

        var view = this.getView();

        view.un('initialize', this.configure, this);
        view.on('beforedestroy', this.destroy, this);

        if (Ext.isObject(this.control)) {
            Ext.Object.each(this.control, function(key, config) {
                var component = this.locateComponent(key, config);

                this.setComponent(key, component);

                if (Ext.isObject(config)) {
                    var listeners = Ext.isObject(config.listeners) ? config.listeners : config;

                    Ext.Object.each(listeners, function(event, handler, obj) {
                        Ext.Logger.log('adding component ' + component + ' event ' + event + ' listener to ' + handler );

                        component.on(event, this[handler], this);
                    }, this);
                }
            }, this);
        }

        if (Ext.isFunction(this.setup)) {
            this.setup();
        }
    },

    /**
     * Destroy the ViewController.
     */
    destroy: function(e) {
        Ext.Logger.log('Destroying view controller.');

        var view = this.getView();
        view.un('beforedestroy', this.destroy, this);

        if (Ext.isFunction(this.tearDown) && this.tearDown() == false)
            return false;

        if (Ext.isObject(this.control)) {
            Ext.Object.each(this.control, function(key, config) {
                var component = this.getComponent( key );

                if (Ext.isObject(config)) {
                    var listeners = Ext.isObject(config.listeners) ? config.listeners : config;

                    Ext.Object.each(listeners, function(event, handler, obj) {
                        Ext.Logger.log('removing component ' + component + ' event ' + event + ' listener to ' + handler);

                        component.un(event, this[handler], this);
                    }, this);
                }

                var getterName = 'get' + Ext.String.capitalize(key);
                this[getterName] = null;

            }, this);
        }

        this.components = null;

        return true;
    },

    locateComponent: function(key, config) {
        var view = this.getView();

        if (key == 'view')
            return view;

        if (Ext.isString(config))
            return view.query(config)[0];

        if (Ext.isString(config.selector))
            return view.query(config.selector)[0];

        return view.query('#' + key)[0];
    },

    getComponent: function(key) {
        return this.components[key];
    },

    setComponent: function(key, value) {
        var getterName = 'get' + Ext.String.capitalize(key);

        // create getter method
        if (!this[getterName])
            this[getterName] = Ext.Function.pass(this.getElement, [key], this);

        this.components[key] = value;
    },

    getView: function() {
        return this.components.view;
    }

});

Ext.define('Deft.util.Deferred', {
  alternateClassName: ['Deft.Deferred'],
  constructor: function() {
    this.state = 'pending';
    this.progress = void 0;
    this.value = void 0;
    this.progressCallbacks = [];
    this.successCallbacks = [];
    this.failureCallbacks = [];
    this.cancelCallbacks = [];
    this.promise = Ext.create('Deft.Promise', this);
    return this;
  },
  /**
  	Returns a new {@link Deft.util.Promise} with the specified callbacks registered to be called when this {@link Deft.util.Deferred} is resolved, rejected, updated or cancelled.
  */
  then: function(callbacks) {
    var cancelCallback, deferred, failureCallback, progressCallback, successCallback, wrapCallback;
    if (Ext.isObject(callbacks)) {
      successCallback = callbacks.success, failureCallback = callbacks.failure, progressCallback = callbacks.progress, cancelCallback = callbacks.cancel;
    } else {
      successCallback = arguments[0], failureCallback = arguments[1], progressCallback = arguments[2], cancelCallback = arguments[3];
    }
    deferred = Ext.create('Deft.Deferred');
    wrapCallback = function(callback, action) {
      if (Ext.isFunction(callback) || callback === null || callback === void 0) {
        return function(value) {
          var result;
          if (Ext.isFunction(callback)) {
            try {
              result = callback(value);
              if (result === void 0) {
                deferred[action](value);
              } else if (result instanceof Ext.ClassManager.get('Deft.util.Promise') || result instanceof Ext.ClassManager.get('Deft.util.Deferred')) {
                result.then(Ext.bind(deferred.resolve, deferred), Ext.bind(deferred.reject, deferred), Ext.bind(deferred.update, deferred), Ext.bind(deferred.cancel, deferred));
              } else {
                deferred.resolve(result);
              }
            } catch (error) {
              deferred.reject(error);
            }
          } else {
            deferred[action](value);
          }
        };
      } else {
        Ext.Error.raise('Error while configuring callback: a non-function specified.');
      }
    };
    this.register(wrapCallback(progressCallback, 'update'), this.progressCallbacks, 'pending', this.progress);
    this.register(wrapCallback(successCallback, 'resolve'), this.successCallbacks, 'resolved', this.value);
    this.register(wrapCallback(failureCallback, 'reject'), this.failureCallbacks, 'rejected', this.value);
    this.register(wrapCallback(cancelCallback, 'cancel'), this.cancelCallbacks, 'cancelled', this.value);
    return deferred.getPromise();
  },
  /**
  	Returns a new {@link Deft.util.Promise} with the specified callbacks registered to be called when this {@link Deft.util.Deferred} is either resolved, rejected, or cancelled.
  */
  always: function(alwaysCallback) {
    return this.then({
      success: alwaysCallback,
      failure: alwaysCallback,
      cancel: alwaysCallback
    });
  },
  /**
  	Update progress for this {@link Deft.util.Deferred} and notify relevant callbacks.
  */
  update: function(progress) {
    if (this.state === 'pending') {
      this.progress = progress;
      this.notify(this.progressCallbacks, progress);
    } else {
      Ext.Error.raise('Error: this Deferred has already been completed and cannot be modified.');
    }
  },
  /**
  	Resolve this {@link Deft.util.Deferred} and notify relevant callbacks.
  */
  resolve: function(value) {
    this.complete('resolved', value, this.successCallbacks);
  },
  /**
  	Reject this {@link Deft.util.Deferred} and notify relevant callbacks.
  */
  reject: function(error) {
    this.complete('rejected', error, this.failureCallbacks);
  },
  /**
  	Cancel this {@link Deft.util.Deferred} and notify relevant callbacks.
  */
  cancel: function(reason) {
    this.complete('cancelled', reason, this.cancelCallbacks);
  },
  /**
  	Get this {@link Deft.util.Deferred}'s associated {@link Deft.util.Promise}.
  */
  getPromise: function() {
    return this.promise;
  },
  /**
  	Get this {@link Deft.util.Deferred}'s current state.
  */
  getState: function() {
    return this.state;
  },
  /**
  	Register a callback for this {@link Deft.util.Deferred} for the specified callbacks and state, immediately notifying with the specified value (if applicable).
  	@private
  */
  register: function(callback, callbacks, state, value) {
    if (Ext.isFunction(callback)) {
      if (this.state === 'pending') callbacks.push(callback);
      if (this.state === state && value !== void 0) this.notify([callback], value);
    }
  },
  /**
  	Complete this {@link Deft.util.Deferred} with the specified state and value.
  	@private
  */
  complete: function(state, value, callbacks) {
    if (this.state === 'pending') {
      this.state = state;
      this.value = value;
      this.notify(callbacks, value);
      this.releaseCallbacks();
    } else {
      Ext.Error.raise('Error: this Deferred has already been completed and cannot be modified.');
    }
  },
  /**
  	@private
  	Notify the specified callbacks with the specified value.
  */
  notify: function(callbacks, value) {
    var callback, _i, _len;
    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
      callback = callbacks[_i];
      callback(value);
    }
  },
  /**
  	@private
  	Release references to all callbacks registered with this {@link Deft.util.Deferred}.
  */
  releaseCallbacks: function() {
    this.progressCallbacks = null;
    this.successCallbacks = null;
    this.failureCallbacks = null;
    this.cancelCallbacks = null;
  }
});

Ext.define('Deft.util.Promise', {
  alternateClassName: ['Deft.Promise'],
  statics: {
    /**
    		Returns a new {@link Deft.util.Promise} with the specified callbacks registered to be called:
    		- immediately for the specified value, or
    		- when the specified {@link Deft.util.Deferred} or {@link Deft.util.Promise} is resolved, rejected, updated or cancelled.
    */
    when: function(promiseOrValue, callbacks) {
      var deferred;
      if (promiseOrValue instanceof Ext.ClassManager.get('Deft.util.Promise') || promiseOrValue instanceof Ext.ClassManager.get('Deft.util.Deferred')) {
        return promiseOrValue.then(callbacks);
      } else {
        deferred = Ext.create('Deft.util.Deferred');
        deferred.resolve(promiseOrValue);
        return deferred.then(callbacks);
      }
    },
    /**
    		Returns a new {@link Deft.util.Promise} that will only resolve once all the specified `promisesOrValues` have resolved.
    		The resolution value will be an Array containing the resolution value of each of the `promisesOrValues`.
    */
    all: function(promisesOrValues, callbacks) {
      var promise, results;
      results = new Array(promisesOrValues.length);
      promise = this.reduce(promisesOrValues, this.reduceIntoArray, results);
      return this.when(promise, callbacks);
    },
    /**
    		Returns a new {@link Deft.util.Promise} that will only resolve once any one of the the specified `promisesOrValues` has resolved.
    		The resolution value will be the resolution value of the triggering `promiseOrValue`.
    */
    any: function(promisesOrValues, callbacks) {
      var complete, deferred, index, progressFunction, promiseOrValue, rejectFunction, rejecter, resolveFunction, resolver, updater, _len;
      deferred = Ext.create('Deft.util.Deferred');
      updater = function(progress) {
        deferred.update(progress);
      };
      resolver = function(value) {
        complete();
        deferred.resolve(value);
      };
      rejecter = function(error) {
        complete();
        deferred.reject(error);
      };
      complete = function() {
        return updater = resolver = rejecter = function() {};
      };
      resolveFunction = function(value) {
        return resolver(value);
      };
      rejectFunction = function(value) {
        return rejector(value);
      };
      progressFunction = function(value) {
        return updater(value);
      };
      for (index = 0, _len = promisesOrValues.length; index < _len; index++) {
        promiseOrValue = promisesOrValues[index];
        if (index in promisesOrValues) {
          this.when(promiseOrValue, resolveFunction, rejectFunction, progressFunction);
        }
      }
      return deferred.then(callbacks);
    },
    /**
    		Traditional map function, similar to `Array.prototype.map()`, that allows input to contain promises and/or values.
    		The specified map function may return either a value or a promise.
    */
    map: function(promisesOrValues, mapFunction) {
      var index, promiseOrValue, results, _len;
      results = new Array(promisesOrValues.length);
      for (index = 0, _len = promisesOrValues.length; index < _len; index++) {
        promiseOrValue = promisesOrValues[index];
        if (index in promisesOrValues) {
          results[index] = this.when(promiseOrValue, mapFunction);
        }
      }
      return this.reduce(results, this.reduceIntoArray, results);
    },
    /**
    		Traditional reduce function, similar to `Array.reduce()`, that allows input to contain promises and/or values.
    */
    reduce: function(promisesOrValues, reduceFunction, initialValue) {
      var reduceArguments, whenResolved;
      whenResolved = this.when;
      reduceArguments = [
        function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
          return whenResolved(previousValueOrPromise, function(previousValue) {
            return whenResolved(currentValueOrPromise, function(currentValue) {
              return reduceFunction(previousValue, currentValue, currentIndex, promisesOrValues);
            });
          });
        }
      ];
      if (arguments.length === 3) reduceArguments.push(initialValue);
      return this.when(this.reduceArray.apply(promisesOrValues, reduceArguments));
    },
    /**
    		Internal reduce implementation - includes fallback when Array.reduce is not available.
    		@private
    */
    reduceArray: function(reduceFunction, initialValue) {
      var args, array, index, length, reduced;
      index = 0;
      array = Object(this);
      length = array.length >>> 0;
      args = arguments;
      if (args.length <= 1) {
        while (true) {
          if (index in array) {
            reduced = array[index++];
            break;
          }
          if (++index >= length) throw new TypeError();
        }
      } else {
        reduced = args[1];
      }
      while (index < length) {
        if (index in array) {
          reduced = reduceFunction(reduced, array[index], index, array);
        }
        index++;
      }
      return reduced;
    },
    /**
    		@private
    */
    reduceIntoArray: function(previousValue, currentValue, currentIndex) {
      previousValue[currentIndex] = currentValue;
      return previousValue;
    }
  },
  constructor: function(deferred) {
    this.deferred = deferred;
    return this;
  },
  /**
  	Returns a new {@link Deft.util.Promise} with the specified callbacks registered to be called when this {@link Deft.util.Promise} is resolved, rejected, updated or cancelled.
  */
  then: function(callbacks) {
    return this.deferred.then.apply(this.deferred, arguments);
  },
  /**
  	Returns a new {@link Deft.util.Promise} with the specified callback registered to be called when this {@link Deft.util.Promise} is resolved, rejected or cancelled.
  */
  always: function(callback) {
    return this.deferred.always(callback);
  },
  /**
  	Cancel this {@link Deft.util.Promise} and notify relevant callbacks.
  */
  cancel: function(reason) {
    return this.deferred.cancel(reason);
  },
  /**
  	Get this {@link Deft.util.Promise}'s current state.
  */
  getState: function() {
    return this.deferred.getState();
  }
}, function() {
  if (Array.prototype.reduce != null) this.reduceArray = Array.prototype.reduce;
});
